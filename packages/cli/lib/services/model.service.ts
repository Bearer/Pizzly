import fs from 'node:fs';
import path from 'node:path';

import chalk from 'chalk';
import type { NangoSyncModel, StandardNangoConfig } from '@nangohq/shared';
import { isJsOrTsType } from '@nangohq/shared';
import { printDebug } from '../utils.js';
import { TYPES_FILE_NAME } from '../constants.js';
import configService from './config.service.js';

export interface YamlToModel {
    name: string;
    interfaceName: string;
    type: 'syncOutput' | 'actionInput' | 'actionOutput';
    parents: string[];
    fields: Record<string, string | Record<string, string>>;
    keyFields: string | Record<string, string> | undefined;
}
export type ModelsMap = Map<string, Record<string, any>>;

export function buildModelsTS({ configs }: { configs: StandardNangoConfig[] }): string {
    const output: string[] = ['// This file was generated by Nango', "// It's recommended to commit it to your VCS", ''];

    const models: ModelsMap = new Map<string, Record<string, any>>();

    // console.log(JSON.stringify(configs));

    // List all models
    for (const config of configs) {
        for (const sync of config.syncs) {
            for (const model of sync.models) {
                models.set(model.name, model.fields);
            }
        }
        for (const action of config.actions) {
            for (const model of action.models) {
                models.set(model.name, model.fields);
            }
            if (action.input) {
                models.set(action.input.name, action.input.fields);
            }
        }
    }

    const interfaces: string[] = [];
    for (const config of configs) {
        // Syncs
        for (const sync of config.syncs) {
            for (const model of sync.models) {
                const hasId = model.fields.find((field) => field.name === 'id');
                if (!hasId) {
                    throw new Error(`Model "${model.name}" doesn't have an id field. This is required to be able to uniquely identify the data record.`);
                }

                interfaces.push(modelToTypescript({ model, models }));
            }
        }

        // Actions
        for (const action of config.actions) {
            for (const model of action.models) {
                interfaces.push(modelToTypescript({ model, models }));
            }
            if (action.input) {
                interfaces.push(modelToTypescript({ model: action.input, models }));
            }
        }
    }

    output.push('// ------ Models');
    output.push(interfaces.join('\n\n\n'));
    output.push('// ------ /Models');
    output.push('');

    output.push(generateSDKTypes({}));

    output.push(`// ------ Flows
export const NangoFlows = ${JSON.stringify(configs, null, 2)} as const;
// ------ /Flows
`);

    return output.join('\n');
}

export function modelToTypescript({ model, models }: { model: NangoSyncModel; models: ModelsMap }) {
    const output: string[] = [];
    const interfaceName = `${model.name.charAt(0).toUpperCase()}${model.name.slice(1)}`;
    output.push(`export interface ${interfaceName} {`);
    for (const field of model.fields) {
        const ts = fieldToTypescript({ rawField: field.type, models, modelName: model.name });
        output.push(`  ${field.name}: ${ts}`);
    }
    output.push(`};`);
    return output.join('\n');
}

/**
 * Transform a field definition to its typescript equivalent
 */
export function fieldToTypescript({ rawField, modelName, models }: { rawField: string; modelName: string; models: ModelsMap }): string {
    if (typeof rawField === 'string') {
        if (rawField.toString().endsWith(',') || rawField.toString().endsWith(';')) {
            throw new Error(`Field "${rawField}" in the model ${modelName} ends with a comma or semicolon which is not allowed.`);
        }

        const types = rawField.split('|');
        const acc = [];
        for (const rawType of types) {
            const trimmed = rawType.trim();
            const isArray = trimmed.endsWith('[]');
            const type = isArray ? fixType(trimmed.substring(0, trimmed.length - 2)) : fixType(trimmed);

            if (isJsOrTsType(type) || models.has(type)) {
                acc.push(`${type}${isArray ? '[]' : ''}`);
            } else {
                acc.push(`'${type}'${isArray ? '[]' : ''}`);
            }
        }

        return acc.join(' | ');
    }

    try {
        const nestedFields = Object.keys(rawField)
            .map((fieldName: string) => `  ${fieldName}: ${fieldToTypescript({ rawField: rawField[fieldName], modelName, models })};`)
            .join('\n');
        return `{\n${nestedFields}\n}`;
    } catch (_) {
        // eslint-disable-next-line no-console
        console.log(chalk.red(`Failed to parse field ${JSON.stringify(rawField)} so just returning it back as a string`));
        return String(rawField);
    }
}

export async function loadYamlAndGeneratedModel({ fullPath, debug = false }: { fullPath: string; debug?: boolean }): Promise<StandardNangoConfig[]> {
    if (debug) {
        printDebug(`Generating ${TYPES_FILE_NAME} file`);
    }

    const fp = path.resolve(fullPath, TYPES_FILE_NAME);
    if (!fs.existsSync(fp)) {
        if (debug) {
            printDebug('First compilation');
        }
    } else {
        if (debug) {
            printDebug(`File already exists, replacing`);
        }
    }

    const { success, error, response: configs } = await configService.load(fullPath, debug);
    if (!success || !configs) {
        console.log(chalk.red(error?.message));
        throw new Error('Failed to load config');
    }

    const modelTs = buildModelsTS({ configs });
    fs.writeFileSync(fp, modelTs);

    if (debug) {
        printDebug(`${TYPES_FILE_NAME} generated`);
    }

    return configs;
}

/**
 * Fix small mistakes users can make (= alias)
 */
export function fixType(type: string) {
    switch (type) {
        case 'bool':
            return 'boolean';
        case 'char':
        case 'varchar':
            return 'string';
        case 'integer':
        case 'int':
            return 'number';
        case 'date':
            return 'Date';
        default:
            return type;
    }
}

export function generateSDKTypes(_models: any) {
    return `
// ------ SDK
import { NangoSync as NangoSyncDefault, NangoAction as NangoActionDefault } from '@nangohq/sdk';

export type Models = {};

export type NangoSync = NangoSyncDefault<Models>;
export type NangoAction = NangoActionDefault<Models>;
// ------ /SDK

`;
}
