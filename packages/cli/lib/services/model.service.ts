import fs from 'node:fs';
import path from 'node:path';

import chalk from 'chalk';
import type { NangoModel, NangoModelField, NangoYamlParsed } from '@nangohq/types';
import type { ServiceResponse } from '@nangohq/shared';
import { NANGO_VERSION } from '@nangohq/shared';
import { getNangoRootPath, printDebug } from '../utils.js';
import { TYPES_FILE_NAME } from '../constants.js';
import { load } from './config.service.js';
import { shouldQuote } from '@nangohq/nango-yaml';

export type ModelsMap = Map<string, Record<string, any>>;

/**
 * Load nango.yaml and generate model.ts
 */
export function loadYamlAndGeneratedModel({ fullPath, debug = false }: { fullPath: string; debug?: boolean }): ServiceResponse<NangoYamlParsed> {
    if (debug) {
        printDebug(`Generating ${TYPES_FILE_NAME} file`);
    }

    const fp = path.resolve(fullPath, TYPES_FILE_NAME);
    if (!fs.existsSync(fp)) {
        if (debug) {
            printDebug('First compilation');
        }
    } else {
        if (debug) {
            printDebug(`File already exists, replacing`);
        }
    }

    const { success, error, response: parsed } = load(fullPath, debug);
    if (!success || !parsed) {
        console.log(chalk.red(error?.message));
        return { success: false, error: null, response: null };
    }

    const modelTs = buildModelsTS({ parsed });
    fs.writeFileSync(fp, modelTs);

    if (debug) {
        printDebug(`${TYPES_FILE_NAME} generated`);
    }

    return { success: true, error: null, response: parsed };
}

/**
 * Build models.ts
 */
export function buildModelsTS({ parsed }: { parsed: NangoYamlParsed }): string {
    const output: string[] = [
        '// ---------------------------',
        `// This file was generated by Nango (v${NANGO_VERSION})`,
        "// It's recommended to version this file",
        '// https://nango.dev',
        '// ---------------------------',
        ''
    ];

    output.push('// ------ Models');
    output.push(generateInterfaces({ parsed }).join('\n\n'));
    output.push('// ------ /Models');
    output.push('');

    output.push('// ------ SDK');
    output.push(generateSDKTypes());
    output.push('// ------ /SDK');
    output.push('');

    output.push(`// ------ Flows
export const NangoFlows = ${JSON.stringify(parsed.integrations, null, 2)} as const;
// ------ /Flows
`);

    return output.join('\n');
}

export function generateInterfaces({ parsed }: { parsed: NangoYamlParsed }): string[] {
    const interfaces: string[] = [];
    for (const [, model] of parsed.models) {
        interfaces.push(modelToTypescript({ model }));
    }

    return interfaces;
}

/**
 * Transform a JSON model to its Typescript equivalent
 */
export function modelToTypescript({ model }: { model: NangoModel }) {
    const output: string[] = [];
    if (model.isAnon) {
        output.push(`/** @deprecated It is recommended to use a Model */`);
        output.push(`export type ${model.name} = ${fieldToTypescript({ field: model.fields[0]! })}`);
    } else {
        output.push(`export interface ${model.name} {`);
        output.push(...fieldsToTypescript({ fields: model.fields }));
        output.push(`};`);
    }
    return output.join('\n');
}

export function fieldsToTypescript({ fields }: { fields: NangoModelField[] }) {
    const output: string[] = [];
    const dynamic = fields.find((field) => field.dynamic);

    // Insert dynamic key at the beginning
    if (dynamic) {
        if (!Array.isArray(dynamic.value)) {
            output.push(`  [key: string]: ${fieldToTypescript({ field: dynamic })};`);
        } else {
            output.push(`  [key: string]: {${fieldsToTypescript({ fields: dynamic.value }).join('\n')}};`);
        }
    }

    // Regular fields
    for (const field of fields) {
        if (field.dynamic) {
            continue;
        }

        output.push(`  ${shouldQuote(field.name) ? `"${field.name}"` : field.name}${field.optional ? '?' : ''}: ${fieldToTypescript({ field: field })};`);
    }

    return output;
}

/**
 * Transform a field definition to its typescript equivalent
 */
export function fieldToTypescript({ field }: { field: NangoModelField }): string | boolean | null | undefined | number {
    if (Array.isArray(field.value)) {
        if (field.union) {
            return field.value.map((f) => fieldToTypescript({ field: f })).join(' | ');
        }
        if (field.array) {
            return `(${field.value.map((f) => fieldToTypescript({ field: f })).join(' | ')})[]`;
        }

        return `{${fieldsToTypescript({ fields: field.value }).join('\n')}}`;
    }
    if (field.model || field.tsType) {
        return `${field.value}${field.array ? '[]' : ''}`;
    }
    if (field.value === null) {
        return 'null';
    }
    if (typeof field.value === 'string') {
        return `'${field.value}${field.array ? '[]' : ''}'`;
    }
    return `${field.value}${field.array ? '[]' : ''}`;
}

/**
 * Generate SDK types
 */
export function generateSDKTypes() {
    const typesContent = fs.readFileSync(`${getNangoRootPath()}/../shared/dist/sdk/sync.d.ts`, 'utf8');

    return `
${typesContent}

`;
}
