import fs from 'node:fs';
import path from 'node:path';

import chalk from 'chalk';
import type { NangoModel, NangoModelField, NangoYamlParsed } from '@nangohq/types';
import type { ServiceResponse } from '@nangohq/shared';
import { NANGO_VERSION } from '@nangohq/shared';
import { getNangoRootPath, printDebug } from '../utils.js';
import { TYPES_FILE_NAME } from '../constants.js';
import { load } from './config.service.js';
import { isJsOrTsType } from '@nangohq/nango-yaml';

export type ModelsMap = Map<string, Record<string, any>>;

/**
 * Load nango.yaml and generate model.ts
 */
export async function loadYamlAndGeneratedModel({ fullPath, debug = false }: { fullPath: string; debug?: boolean }): Promise<ServiceResponse<NangoYamlParsed>> {
    if (debug) {
        printDebug(`Generating ${TYPES_FILE_NAME} file`);
    }

    const fp = path.resolve(fullPath, TYPES_FILE_NAME);
    if (!fs.existsSync(fp)) {
        if (debug) {
            printDebug('First compilation');
        }
    } else {
        if (debug) {
            printDebug(`File already exists, replacing`);
        }
    }

    const { success, error, response: parsed } = await load(fullPath, debug);
    if (!success || !parsed) {
        console.log(chalk.red(error?.message));
        if (error?.payload) {
            console.log(error.payload);
        }
        return { success: false, error: null, response: null };
    }

    const modelTs = buildModelsTS({ parsed });
    fs.writeFileSync(fp, modelTs);

    if (debug) {
        printDebug(`${TYPES_FILE_NAME} generated`);
    }

    return { success: true, error: null, response: parsed };
}

/**
 * Build models.ts
 */
export function buildModelsTS({ parsed }: { parsed: NangoYamlParsed }): string {
    const output: string[] = [
        '// ---------------------------',
        `// This file was generated by Nango (v${NANGO_VERSION})`,
        "// It's recommended to version this file",
        '// https://nango.dev',
        '// ---------------------------',
        ''
    ];

    output.push('// ------ Models');
    output.push(generateInterfaces({ parsed }).join('\n\n'));
    output.push('// ------ /Models');
    output.push('');

    output.push('// ------ SDK');
    output.push(generateSDKTypes());
    output.push('// ------ /SDK');
    output.push('');

    output.push(`// ------ Flows
export const NangoFlows = ${JSON.stringify(parsed.integrations, null, 2)} as const;
// ------ /Flows
`);

    return output.join('\n');
}

export function generateInterfaces({ parsed }: { parsed: NangoYamlParsed }): string[] {
    const models: ModelsMap = new Map<string, Record<string, any>>();

    const interfaces: string[] = [];
    for (const integration of parsed.integrations) {
        // Syncs
        for (const sync of integration.syncs) {
            for (const model of sync.models) {
                interfaces.push(modelToTypescript({ model, models }));
            }
        }

        // Actions
        for (const action of integration.actions) {
            for (const model of action.models) {
                interfaces.push(modelToTypescript({ model, models }));
            }
            if (action.input && typeof action.input !== 'string') {
                interfaces.push(modelToTypescript({ model: action.input, models }));
            }
        }
    }

    return interfaces;
}

/**
 * Transform a JSON model to its Typescript equivalent
 */
export function modelToTypescript({ model, models }: { model: NangoModel; models: ModelsMap }) {
    const output: string[] = [];
    const interfaceName = `${model.name.charAt(0).toUpperCase()}${model.name.slice(1)}`;
    output.push(`export interface ${interfaceName} {`);

    output.push(...fieldsToTypescript({ fields: model.fields, models }));

    output.push(`};`);
    return output.join('\n');
}

export function fieldsToTypescript({ models, fields }: { fields: NangoModelField[]; models: ModelsMap }) {
    const output: string[] = [];
    const dynamic = fields.find((field) => field.dynamic);

    // Insert dynamic key at the beginning
    if (dynamic) {
        if (typeof dynamic.value === 'string') {
            const ts = fieldToTypescript({ rawField: dynamic.value, models, modelName: dynamic.name });
            output.push(`  ${dynamic.name}: ${ts};`);
        } else {
            output.push(`  [key: string]: {${fieldsToTypescript({ models, fields: dynamic.type }).join('\n')}};`);
        }
    }

    // Regular fields
    for (const field of fields) {
        if (field.dynamic) {
            continue;
        }
        if (typeof field.value === 'string') {
            const ts = fieldToTypescript({ rawField: field.value, models, modelName: field.name });
            output.push(`  ${field.name}: ${ts};`);
        } else {
            output.push(`  ${field.name}: {${fieldsToTypescript({ models, fields: field.value }).join('\n')}};`);
        }
    }
    return output;
}

/**
 * Transform a field definition to its typescript equivalent
 */
export function fieldToTypescript({ rawField, modelName, models }: { rawField: string; modelName: string; models: ModelsMap }): string {
    if (rawField.toString().endsWith(',') || rawField.toString().endsWith(';')) {
        throw new Error(`Field "${rawField}" in the model ${modelName} ends with a comma or semicolon which is not allowed.`);
    }

    const types = rawField.split('|');
    const acc = [];
    for (const rawType of types) {
        const trimmed = rawType.trim();
        const isArray = trimmed.endsWith('[]');
        const type = isArray ? fixType(trimmed.substring(0, trimmed.length - 2)) : fixType(trimmed);

        if (isJsOrTsType(type) || models.has(type)) {
            acc.push(`${type}${isArray ? '[]' : ''}`);
        } else {
            acc.push(`'${type}'${isArray ? '[]' : ''}`);
        }
    }

    return acc.join(' | ');
}

/**
 * Fix small mistakes users can make (= alias)
 */
export function fixType(type: string) {
    switch (type) {
        case 'bool':
            return 'boolean';
        case 'char':
        case 'varchar':
            return 'string';
        case 'integer':
        case 'int':
            return 'number';
        case 'date':
            return 'Date';
        default:
            return type;
    }
}

/**
 * Generate SDK types
 */
export function generateSDKTypes() {
    const typesContent = fs.readFileSync(`${getNangoRootPath()}/../shared/dist/sdk/sync.d.ts`, 'utf8');

    return `
${typesContent}

`;
}
