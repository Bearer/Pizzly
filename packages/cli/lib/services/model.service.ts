import fs from 'node:fs';
import path from 'node:path';

import chalk from 'chalk';
import type { NangoSyncModel, ServiceResponse, StandardNangoConfig } from '@nangohq/shared';
import { NANGO_VERSION, isJsOrTsType } from '@nangohq/shared';
import { getNangoRootPath, printDebug } from '../utils.js';
import { TYPES_FILE_NAME } from '../constants.js';
import configService from './config.service.js';

export type ModelsMap = Map<string, Record<string, any>>;

/**
 * Load nango.yaml and generate model.ts
 */
export async function loadYamlAndGeneratedModel({
    fullPath,
    debug = false
}: {
    fullPath: string;
    debug?: boolean;
}): Promise<ServiceResponse<StandardNangoConfig[]>> {
    if (debug) {
        printDebug(`Generating ${TYPES_FILE_NAME} file`);
    }

    const fp = path.resolve(fullPath, TYPES_FILE_NAME);
    if (!fs.existsSync(fp)) {
        if (debug) {
            printDebug('First compilation');
        }
    } else {
        if (debug) {
            printDebug(`File already exists, replacing`);
        }
    }

    const { success, error, response: configs } = await configService.load(fullPath, debug);
    if (!success || !configs) {
        console.log(chalk.red(error?.message));
        return { success: false, error: null, response: null };
    }

    const modelTs = buildModelsTS({ configs });
    fs.writeFileSync(fp, modelTs);

    if (debug) {
        printDebug(`${TYPES_FILE_NAME} generated`);
    }

    return { success: true, error: null, response: configs };
}

/**
 * Build models.ts
 */
export function buildModelsTS({ configs }: { configs: StandardNangoConfig[] }): string {
    const output: string[] = [
        '// ---------------------------',
        `// This file was generated by Nango (v${NANGO_VERSION})`,
        "// It's recommended to version this file",
        '// https://nango.dev',
        '// ---------------------------',
        ''
    ];

    output.push('// ------ Models');
    output.push(generateInterfaces({ configs }).join('\n\n'));
    output.push('// ------ /Models');
    output.push('');

    output.push('// ------ SDK');
    output.push(generateSDKTypes());
    output.push('// ------ /SDK');
    output.push('');

    output.push(`// ------ Flows
export const NangoFlows = ${JSON.stringify(configs, null, 2)} as const;
// ------ /Flows
`);

    return output.join('\n');
}

export function generateInterfaces({ configs }: { configs: StandardNangoConfig[] }): string[] {
    const models: ModelsMap = new Map<string, Record<string, any>>();

    // List all models
    for (const config of configs) {
        for (const sync of config.syncs) {
            for (const model of sync.models) {
                models.set(model.name, model.fields);
            }
        }
        for (const action of config.actions) {
            for (const model of action.models) {
                models.set(model.name, model.fields);
            }
            if (action.input && typeof action.input !== 'string') {
                models.set(action.input.name, action.input.fields);
            }
        }
    }

    const interfaces: string[] = [];
    for (const config of configs) {
        // Syncs
        for (const sync of config.syncs) {
            for (const model of sync.models) {
                interfaces.push(modelToTypescript({ model, models }));
            }
        }

        // Actions
        for (const action of config.actions) {
            for (const model of action.models) {
                interfaces.push(modelToTypescript({ model, models }));
            }
            if (action.input && typeof action.input !== 'string') {
                interfaces.push(modelToTypescript({ model: action.input, models }));
            }
        }
    }

    return interfaces;
}

/**
 * Transform a JSON model to its Typescript equivalent
 */
export function modelToTypescript({ model, models }: { model: NangoSyncModel; models: ModelsMap }) {
    const output: string[] = [];
    const interfaceName = `${model.name.charAt(0).toUpperCase()}${model.name.slice(1)}`;
    output.push(`export interface ${interfaceName} {`);
    for (const field of model.fields) {
        const ts = fieldToTypescript({ rawField: field.type, models, modelName: model.name });
        output.push(`  ${field.name}: ${ts}`);
    }
    output.push(`};`);
    return output.join('\n');
}

/**
 * Transform a field definition to its typescript equivalent
 */
export function fieldToTypescript({ rawField, modelName, models }: { rawField: string; modelName: string; models: ModelsMap }): string {
    if (typeof rawField === 'string') {
        if (rawField.toString().endsWith(',') || rawField.toString().endsWith(';')) {
            throw new Error(`Field "${rawField}" in the model ${modelName} ends with a comma or semicolon which is not allowed.`);
        }

        const types = rawField.split('|');
        const acc = [];
        for (const rawType of types) {
            const trimmed = rawType.trim();
            const isArray = trimmed.endsWith('[]');
            const type = isArray ? fixType(trimmed.substring(0, trimmed.length - 2)) : fixType(trimmed);

            if (isJsOrTsType(type) || models.has(type)) {
                acc.push(`${type}${isArray ? '[]' : ''}`);
            } else {
                acc.push(`'${type}'${isArray ? '[]' : ''}`);
            }
        }

        return acc.join(' | ');
    }

    try {
        const nestedFields = Object.keys(rawField)
            .map((fieldName: string) => `  ${fieldName}: ${fieldToTypescript({ rawField: rawField[fieldName], modelName, models })};`)
            .join('\n');
        return `{\n${nestedFields}\n}`;
    } catch (_) {
        console.log(chalk.red(`Failed to parse field ${JSON.stringify(rawField)} so just returning it back as a string`));
        return String(rawField);
    }
}

/**
 * Fix small mistakes users can make (= alias)
 */
export function fixType(type: string) {
    switch (type) {
        case 'bool':
            return 'boolean';
        case 'char':
        case 'varchar':
            return 'string';
        case 'integer':
        case 'int':
            return 'number';
        case 'date':
            return 'Date';
        default:
            return type;
    }
}

/**
 * Generate SDK types
 */
export function generateSDKTypes() {
    const typesContent = fs.readFileSync(`${getNangoRootPath()}/../shared/dist/sdk/sync.d.ts`, 'utf8');

    return `
${typesContent}

`;
}
